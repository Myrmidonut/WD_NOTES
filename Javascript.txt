FILES:
  external:
    <html>
      <body>
        ...
        <script src="name.js"></script>
      </body>
    </html>

  internal:
    <html>
      <body>
        <script>
          ...
        </script>
      </body>
    </html>

  type="text/javascript"                for old HTML4

  multiple <script></sript> possible

  also possible inside <head> but it will be loaded before the HTML, better at the end of <body>
---------------------------------------------------------------------------------------------------
VERSIONS:
  ECMAScript 5 = JavaScript 1.8.5
  ECMAScript 6 = ECMAScript 2015 (const, let)     IE11
  ECMAScript 7 = ECMAScript 2016
---------------------------------------------------------------------------------------------------
STRICT MODE
  enables modern features
  classes and modules automatically enable strict
  no turning back

  "use strict";                         at the top of the page to enable it
---------------------------------------------------------------------------------------------------
EVENT BUBBLING:
  events inside multiple layers can trigger multiple times on different tags
  $("span").click(function(event){
    ...
    event.stopPropagation();
  });
---------------------------------------------------------------------------------------------------
COMMENTS:
  // ...                                one line comment
  /* ... */                             multi-line comment
---------------------------------------------------------------------------------------------------
CONSOLE:
  console.log(...);                     outputs into the console
  console.table(...);                   outputs into the console as a table
  clear();                              clears the console in chrome
  alert(...);                           shows a window with text, etc.
  prompt(..., ...);                     shows a window with a message (and default text) and input
  confirm(...);                         shows a window with OK and Cancel
---------------------------------------------------------------------------------------------------
OPERATORS:
  unary                                 one operand, -5
  binary                                two operands, 5 - 5

  operand                               

  arithmetic:
    +
    -
    *
    /
    ++                                  prefix: ++i (first increment, then return), postfix: i++
    --
    %
    **                                  exponent

  concatenation:
    "ab" + "cd" == "abcd"               if either is a string, the result becomes a string
    myString += "ab";                   ads a string to the end

  assignment:
    =
    +=                                  x = x + y
    -=
    *=
    /=
    %=
---------------------------------------------------------------------------------------------------
COMPARISON:
  returns true or false
  
  only null == only undefined

  conversion to numbers, except for strict (not) equal

  >                                     greater than
  <                                     less than
  >=                                    greater or equal
  <=                                    less or equal
  ===                                   strict/identity equal, with type
  ==                                    equal
  !==                                   strict/identity not equal, with type
  !=                                    not equal

  comparing strings:
    letter by letter
    letter > number
    special letters > z > a > Z > A > 9 > 0
    stops at greater letter, or longer string
---------------------------------------------------------------------------------------------------
LOGIC:
  &&                                    and, true if both true
  ||                                    or, true if at least one is true
  !                                     not

  x = a || b || c;                      return first true or last value
  x = a && b && c;                      return first false or last value
---------------------------------------------------------------------------------------------------
REGULAR EXPRESSIONS:
  /.../               first occurence
  /.../g              global occurence
  /.../i              case insensitive

  ...|...             or

  (...)               group, following regex is applied to the whole group

  (...)(...)...\2...\1    group, numbers indicate which group is repeated at that position

  [abc]               range
  [a-c]               range
  [a-c2-5]            multiple ranges

  .                   anything

  \d                  [0-9]
  \D                  not \d or [^0-9]
  \w                  [A-Za-z0-9_]
  \W                  not \w or [^A-Za-z0-9_]

  \s                  space, including new line, carriage return, tab, form feed
  \S                  not space

  \...                special characters like ( )

  \r                  return
  \n                  newline
  \t                  tab
  \f                  form feed

  \b                  start or end of word

  [^...]              negation
  ...+                one or more times
  ...*                zero or more times, longest possible
  ...*?               zero or more times, shortest possible
  ...?                zero or one time
  ...?                shortest possible
  ...{...}            exact amount
  ...{...,}           min amount
  ...{...,...}        min to max amount

  ^...                only at the beginning
  ...$                only at the end

  ^...$               exact match

  (?=...)             exists            
  (?!=...)            not exists

  invert using uppercase letter

  escape with:
    \\...

  match:
    .match(myRegex);            returns array with matched regex

  test:
    myRegex = /.../;
    myRegex.test(...);          check if the expression exists in the variable

  replace:
    .replace(myRegex, "...");   replace text in a string
---------------------------------------------------------------------------------------------------
PRECEDENCE:
  ()
    ++
    --
      !
        *
        /
        %
          +
          -
            &&
              ||
---------------------------------------------------------------------------------------------------
VARIABLES:
  let name;                             block-scope, prefered, cannot be redeclared
  const NAME_NAME;                      block-scope, cannot be reassigned
  var name;                             global scope, local scope inside function

  var name;                             undefined
  var name = "test";                    string
  var name = 1;                         number
  var name = true;                      boolean
  var name1 = "test",
      name2 = 1;
  var name = null;                      undefined

  const NAME = ...;                     constant, value is known before execution

  const array;                          entries can still be changed
  Object.freeze(array);                 entries are locked too

  hoisting:
    declaration is at the start of the block
    assignment is at the position in the code
---------------------------------------------------------------------------------------------------
SCOPE:
  var ...                               exists in the function or global
  let ...                               exists in the block, { }
  const ...                             exists in the block, { }
---------------------------------------------------------------------------------------------------
NAMING CONVENTION:
  lowerUpperUpper
  CONST_VARIABLE
  can contain
    $
    _
    letters
    numbers
  cannot start with a number
---------------------------------------------------------------------------------------------------
DATA TYPES:
  primitive:
    number                              integer or float, 4  9.3  -10
      Infinity                          infinity, 1 / 0
      NaN                               computational error, "test" / 2, makes everything NaN
    string                              "Hello World"  "43"
    boolean                             true  false
    null                                represents empty, can be assigned to a variable
    undefined                           value of a variable without assignment

  complex:
    object                              collection of data
      symbol                            unique identifiers for objects
      array                             an ordered object

  typeof ...                            return string with the datatype, error: typeof(null) returns object
    "number"
    
  instanceof ...                        

  if (typeof name == "undefined") {}    checks if the variable called name exists
---------------------------------------------------------------------------------------------------
TYPE CONVERSION:
  String(...)
    .toString()
    ..toString()            directly on a number

  Number(...)
    .toNumber()

    undefined  -> NaN
    null       -> 0
    true/false -> 1/0
    string     -> whitespace removed, becomes a number, empty becomes 0, error becomes NaN

    mathematical operations create numbers, exception: + with a string creates a string
    +... == Number(...)

    addition with string creates string

    1 + "2" == "12"                       number + string == string
    1 - "2" == -1                         number - string == number
    1 * "2" == 2                          number * string == number
    " -9\n" + 5 == " -9\n5"
    " -9\n" - 5 == -14

  Boolean(...)
    " "        -> true
    "0"        -> true

    0          -> false
    ""         -> false
    null       -> false
    undefined  -> false
    NaN        -> false
---------------------------------------------------------------------------------------------------
NUMBERS:
  declaration:
    let x = 1;                          integer
    let x = 1.1;                        floating point
    let x = 1e3;                        1 x 10³ == 1000
    let x = -1e3;                       1 : 10³ == 1/1000

  unusual numbers:
    7 / 0 == Infinity
    null + 1 == 1
    undefined + 1 == NaN

  precision:
    0.1 + 0.2 == 0.3                    false, actually: 0.30000000000000004
    correction with .toFixed(2)

  NaN / Infinite:
    isNaN(...);                         check if NaN
    isFinite(...);                      check if NaN, Infinity, -Infinity  
---------------------------------------------------------------------------------------------------
STRINGS:
  declaration:
    myString = "...";               string literal, doublequotes
    myString = '...';               string literal, singlequotes
    myString = `...`;               string literal, backticks, template literal, multiline
      `... ${...} ...`              allows embedding of variables and expressions into a string

  escape character:
    \                               escape character to use special characters in a string
      \'                            '
      \"                            "
      \\                            \
      \n                            newline
      \r                            carriage return
      \t                            tab
      \b                            backspace
      \f                            form feed

  characters:
    myString[2]                     access to the third character, UNSAFE! convert to array first
    "..."[2]

  infos:
    strings are immutable, it is not possible to change individual letters
---------------------------------------------------------------------------------------------------
BOOLEAN:
  false:
    false
    0
    ""
    null 
    undefined
    NaN

  true:
    everthing else, check with !!var

  true + false == 1
  let isGreater = 4 > 1;                isGreater == true

  result of comparison is boolean
---------------------------------------------------------------------------------------------------
ARRAYS:                                   ordered list of data
  declaration:
    var myArray = [];                     create an empty array
    var myArray = [1, "two", [3, 4]];     create an array
    var myArray = new Array();            create an empty array, slower

  modify:
    myArray[0] = ...;                     modify element at index 0

  nesting:
    myArray[3][4]                         nested array
    myArray[[1, 2], [3, 4]]               nested array


  typeof(...)                                               arrays appear as objects
  Array.isArray(...)                                        check for an array
  function isArray(x) {                                     check for an array in older browsers
    return x.constructor.toString().indexOf("Array") > -1;
  }
  ... instanceof Array                                      returns true for arrays

  info:
    adding elements at high indexes create undefined holes
    may end with a trailing comma
---------------------------------------------------------------------------------------------------
OBJECTS:
  overview:
    var myObj = {property1, property2}
    property = key: value

  declaration:
    var myObj = {};                             create an empty object        
    var myObj = {key: "value", ...};            create an object, key: value pairs (properties)
    var myObj = {"key key": "value"}            multiword key

    var myObj = {key: [...] };                  array key

    var myObj = {key: function() {} };          method key
    var myObj = {key() {} };                    shorter

    var myObj = {key: {key: ..., ...}, ...};    subnamespace

    var myOby = [{...}, {...}];                 array of objects

  constructor:
    function MyObj() {                          constructor, capitalized
      let ... = ...;                            private property, changed only inside constructor
      this.name = ...;
    };

    function MyObj(name) {this.name = name};    constructor with arguments

  instance:
    var myIns = new MyObj();                    create instance with constructor
    var myIns = new MyObj(...);                 create instance with arguments

    myIns instanceof MyObj;                     true if created with constructor, prefered
    myIns.constructor === true                  true if created with constructor

  prototype:
    MyObj.prototype = {                         shared for all instances
      constructor: MyObj,                       keep constructor definition
      ...
    };

    MyObj.prototype.isPrototypeOf(myIns);       true if MyObj is the prototype for myIns
    Object.prototype.isPrototypeOf(MyObj.prototype)

  inheritance:
    let parent = new Parent();                          not recommended

    let parent = Object.create(Parent.prototype);       make instance of parent
    Child.prototype = Object.create(Parent.prototype);  set prototype of child to instance of parent
    Child.prototype.constructor = Child;                set instances of Child to be constructed by Child, and not Parent

    Child.prototype.name = function() {...};            add method after inheritance, overwrites

  mixin:
    let myMixin = function(obj) {         take object and give it a method, for unrelated objects
      obj.name = function() {
        ...;
      }
    };

    myMixin(myObj);                       give myObj the method

    myObj.name();                         use method

  mixin module:
    let myModule = (function() {          multiple mixins combined into a module
      return {
        myMixin1: function(obj) {
          obj.name1 = function() {
            ...;
          };
        },
        myMixin2: function(obj) {
          obj.name2 = function() {
            ...;
          };
        }
      }
    })();

    myModule.myMixin1(myIns);             set the method
    myIns.name1();                        use method

  call:
    myObj.key;                            calling a property
    myObj.key[0];                         calling an array property
    myObj.meth();                         calling a method
    myObj.key.key;                        calling subnamespace
    myObj["key key"];                     calling multiword key

  modify:
    myObj.key = ...;                      modify
    myObj["key"] = ...                    alternative

    myObj[key] = value;

  method:
    myMethod() {...}                      function not necessary inside objects
 
  this:
    .this                                 refers to the current object

  stuff:
    .hasOwnProperty("...")                check if property exists

    delete myObj.key;                     delete property

    Object.keys(...);                     create array containing all keys

    "key" in myObj                        check if property exists

    for...in loop:                        loop over all keys
      for (let key in myObj) {
        alert(key);
        alert(user[key]);
      }

    function isEmpty(obj) {               check if object has no properties
      for (let key in obj) {
        return false;
      } else return true;
    }

  infos:
    data items: properties
    functions: methods

    last property can have a trailing comma, easier moving of properties

    . notation is simpler
    [] notation is more complex

    const myObj {} it is still possible to change properties, only myObj itself is protected
---------------------------------------------------------------------------------------------------
FUNCTIONS:
  declaration:
    function myFunc(arg1, arg2 = "...") {         function declaration, with default value
      ...;
      return ...;                                 optional, will stop the function
    }

  calling:
    myFunc;                                       passing the function on
    myFunc();                                     calling the function immediately

  return:
    return comparison;                            return true or false

  arguments with rest operator:
    function myFunc(...args) {}                   variable number of arguments, stored in array args
    arguments[]                                   array created from arguments

  arguments with spread operator:
    arr = [...];
    Math.max(...arr);                             spreads array when multiple arguments are needed

    let arr2 = [...arr1];

  event:
    let myFunc = function(e) {e...}               function with event object

  arrow function:
    let myFunc = (e) => {}                        arrow function, short version of declaration
                                                  without {} return can be skipped

  function expression:
    let myFunc = function func() {}               function expression
    let myFunc = function() {}                    anonymous function expression
    (function() {...})();                         executed anonymous function expression

  prototype:
    Array.prototype.myFunc = function(func) {     prototype, this to call on the array
      func(this[i]);
    }

  callback:
    function myFunc(arg, function(err, data) {
      if (err) {
        console.log(err);
      } else {
        ...;
      }
    });

    function first(..., callback) {
      ...
      callback();                                 can contain arguments for second()
    }

    function second() {                           arguments from callback();
      ...
    }

  currying:
    function name(a, b) {                         not curried
      return a + b;
    }

    function name(a) {                            curried, when argument b is available later on
      return function(b) {
        return a + b;
      }
    }

  info:
    variables inside a function are only availabe in the function, scope!
    a function does only one thing
    no/empty return returns undefined
    chose declaration over expression, can be called before declaration
    arrow function uses this of outer function

  naming:
    get...
    show...
    calc...
    create...
    check...
---------------------------------------------------------------------------------------------------
METHODS:
  overview:
    a function inside an object

  declaration:
    obj.func = function() {             creating the method
      ...
    }

  calling:
    obj.func();                         calling the method
---------------------------------------------------------------------------------------------------
NUMBER METHODS:
  round:
    Math.round();                         round to nearest whole number
    Math.floor(...);                      round down
    Math.ceil(...);                       round up
    Math.trunc(...);                      remove decimal, not IE!

  decimals:
    Math.round(x * 100) / 100);           avoid float issues
    x.toFixed(2);                         round up or down, creates string, added zeros

  random:
    Math.random();                        random number between 0 and 1, e.g. 0.123, but not 1
      Math.random() * 5;                  random number between 0 and 5, e.g. 2.123, but not 5!
      Math.random() * 5 + 1;              random number between 1 and 5, including 1 and 5
    Math.floor(Math.random() * 5 + 1);    random number out of 1, 2, ..., 5
    Math.floor(Math.random() * (max - min + 1)) + min;    random number from min to max

  min / max:
    Math.max(..., ...);                   maximum of arguments
    Math.min(..., ...);                   minimum of arguments

  exponent:
    Math.pow(base, exponent);             exponent

  root:
    Math.sqrt(...);                       root

  pi:
    Math.PI;                              pi

  change base:
    parseInt(..., ...);                   convert string to number, optional base

  see Math library for  more
---------------------------------------------------------------------------------------------------
STRING METHODS:
  length:
    .length                             length of string

  search:
    .indexOf("...", ...)                return first position of ..., -1 if not, optional start
    .lastIndexOf("...", ...)            return last position of ..., -1 if not, optional start
    .search("...")                      see indexOf, no second argument, with regular expressions
    .match(...)                         search regexp, return array

  search, modern:  
    .includes("...", ...)               true if found, optional start
    .startsWith("...")                  true if found at start
    .endsWith("...")                    true if found at end

  character:
    .charAt(5)                          == [5], return the character at index 5
    .charCodeAt(5)                      return the unicode character at index 5
    String.fromCharCode(...)            get chacracter from unicode

  substring:
    .slice(..., ...)                    return string from start to optional exclusive end
    .slice(-..., -...)                  negative values count from the end
    .substring(..., ...)                see .slice, no negative indixes, starts at lower number
    .substr(..., ...)                   return string from start with optional length
    .substr(-..., ...)                  negative values count from the end

  replace:
    .replace("text1", "text2")          replace the text1 with text2
    .replace(/text1/g , "text2")        replace all text1 with text2
    .replace(/text1/i , "text2")        replace all text1 with text2, case insensetive
    .replace(/...|.../g , "...")        replace multiple texts
    .trim()                             remove leading and ending whitespace

  convert:
    .toUpperCase()                      convert to uppercase
    .toLowerCase()                      convert to lowercase

  add:
    .concat("...", text2)               add string
    .repeat(...)                        repeat ... times

  split:
    .split(...)                         return array, split at character, regex or string
    .split("")                          split every character
---------------------------------------------------------------------------------------------------
ARRAY METHODS:    
  length:
    .length                             number of entries, can be modified

  copy:
    .slice()                            return copy of array

  reverse:
    .reverse()                          M, reverse the array itself

  convert to string:
    .toString()                         convert to string with comma seperation
    .join("...")                        return string with given seperation

  add:
    .unshift(..., ...)                  M, add one or more entries to the beginning
    .push(..., ...)                     M, add one or more entries to end
    .concat(...)                        return array with pushed entries

  remove:
    .shift()                            M, remove first entry, returns it, return entry
    .pop()                              M, remove last entry, returns it, return entry
    .splice(..., ..., ...)              M, start, optional cut amount, optional adds, return cut arr

    delete myArray[5]                   changes element at index 5 to undefined

  extract:
    .slice(..., ...)                    return array from start to optional exclusive end, index

  copy:
    let arr1 = [..., ...arr2, ...];     copy with spread operator

  combine:
    .concat(...)                        return merged array
    .concat("...", "...")               merge values

  search:
    .indexOf(..., ...)                        return first index, optional start, -1 if not
    .lastIndexOf(..., ...)                    return last index, optional start, -1 if not
    .includes(..., ...)                       return true if found, optional start
    .find(function(e) {...})                  search in array of objects, return first entry
    .findIndex(function(e) {...})             see .find, return index

  iterate:
    .filter(e => {...})                       return array with passed, check every entry
    .map(e => {...})                          return array, run function on every entry
    .forEach((e, i) => {...})                 run function on every element with index
    .reduce((total, e) => {...}, init)        return value after iterating into total, optional init
    .some(e => {...})                         return true if at least one result is true
    .every(e => {...})                        return true if all results are true
    .fill(..., ..., ...)                      fill array with value, from start to end
    .copyWithin(..., ..., ...)                copies elements into target, from start to end
    let uniq = [...new Set(myArr)];           remove duplicate entries, keep order

  sort:
    .sort()                               M, sort the array itself from lowest to highest value
    .sort(function(a, b) {return b-a;});  sort high to low
      return a-b                          sort low to high
      return a>b                          sort alphabetically
      return a<b                          sort reverse alphabetically

      if (a[1] < b[1]) return -1;         compare nested arrays
      if (a[1] > b[1]) return 1;

  spread:
    arr = [1, 2, 3]
    ...arr                                spreads entries into individuals, for multiple arguments

  destructure:
    let [a,,,b] = [1,2,3,4]               a=1, b=4
    let [a, b,, ...arr] = [1,2,3,4,5]     a=1, b=2, arr=[4,5]

  loop:
    for ... of

  outputting an array converts it to a comma seperated string

  example:
    const squaredIntegers = arr.filter((e) => e >= 0 && e % 1 === 0).map((e) => e*e);
      returns positive, whole numbers from an array and squares them
---------------------------------------------------------------------------------------------------
CONDITIONS:
  IF ELSE:
    if (condition) {                            if statement
      ...
    } else if (condition) {
      ...
    } else {
      ...
    }

    if(0) {...}                                 check for boolen type conversion
  -------------------------------------------------------------------------------------------------
  SWITCH:
    switch (expression) {                       switch statement
      case choice1:
        ...
        break;                                  leave switch if it is a match

      case choice2:
        ...
        break;

      default:                                  optional
        ...
    }
  -------------------------------------------------------------------------------------------------
  TERNARY:
    condition ? true : false;                   ternary, can be chained

    (...) ? (..., ...) : (..., ...);

    function checkSign(num) {
      return (num > 0) ? "positive" : num < 0 ? "negative" : "zero";
    }
  -------------------------------------------------------------------------------------------------
  BREAK CONTINUE LABEL:
    if (condition) {                            break, leave whole loop
      break;
    }

    if (condition) {                            continue, leave current iteration
      continue;
    }

    label1: for () {                            label, leave both loops
      for () {
        if () {
          break label1;
        }
      }
    }
---------------------------------------------------------------------------------------------------
LOOPS:
  FOR:
    for (init; end; increment) {                for loop
      ...
    }

      if (...) break;                           exit the loop early
      if (...) continue;                        jump to next iteration
  -------------------------------------------------------------------------------------------------
  WHILE:
    init;
    while (condition) {                         while loop
      ...
      increment;
    }
  -------------------------------------------------------------------------------------------------
  DO WHILE:
    init;
    do {                                        do while loop, always run at least once
      ...
      increment;
    } while (condition)
  -------------------------------------------------------------------------------------------------
  FOR OF:
    for (let char of "test") {
      ...
    }
---------------------------------------------------------------------------------------------------
TIME DATE:
  YYYY-MM-DD                            ISO standard
  YYYY-MM-DDTHH:MM:SS

  let date = new Date();                get current date and time, create date object
    date.getTime();                     milliseconds since jan 1, 1970
      .getFullYear()                    YYYY
      .getMonth()                       0-11
      .getDate()                        1-31
      .getDay()                         0-6
      .getHours()                       0-23
      .getMinutes()                     0-59
      .getSeconds()                     0-59
      .getMilliseconds()                0-999

  let msec = Date.parse("...");         convert to milliseconds:
---------------------------------------------------------------------------------------------------
JSON AJAX:
  conversion:
    JSON.parse(..., ...);                         JSON string to object, optional function

    JSON.stringify(...);                          object to JSON string
    JSON.stringify(value, replacer, space)  
      value:    a value
      replacer: array or function
      space:    number for indentation

    toJSON();

  from API:
    let reqURL = "...";                           store URL
    let req = new XMLHttpRequest();               create request object
    req.open("GET", reqURL, true);                initialize request, HTTP method, URL, async true
    req.responseType = "json";                    server will return JSON, "", "text", ...
    req.send();                                   send request
    req.onload = function() {                     wait for response before using it
      let res = req.response;                     when server returns JSON object
      ...                                         use data
    }

  to API:
    let req = new XMLHttpRequest();
    req.open("POST", reqUrl, true);
    req.setRequestHeader("Content-Type", "text/plain");
    req.onreadystatechange = function() {
      if (req.readyState == 4 && req.status == 200) {       successful request
        ...
      }
    }
    req.send(username);                                     send the data

  fetch:
      fetch(url)
        .then(response => {
          return response.json();
        }).then(jsonData => {
          console.log(jsonData);
        }).catch(err => {
          console.log("Error: ", err);
        })
---------------------------------------------------------------------------------------------------
LOCATION:
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(function(position) {
      document.getElementById('data').innerHTML = 
        "latitude: " + position.coords.latitude + 
        "<br>longitude: " + position.coords.longitude;
    });
  }
---------------------------------------------------------------------------------------------------
USEFUL FUNCTIONS:
  setTimeout(function, ms);             execution after time in ms
  setInterval(function, ms);            repeated execution after time in ms

  String.fromCharCode(...);             get value from ASCII code
---------------------------------------------------------------------------------------------------
IMPORT:
  import { ..., ... } from "...";       import functions from a file, ./...

  import * as ... from ...;             import everything from a file into an object

  import ... from "...";                import default value from a file
---------------------------------------------------------------------------------------------------
EXPORT:
  export { ... };                       export a function
  export const foo = "bar";             export a variable
  export { ..., foo };                  export multiple functions and variables

  export default function ... (...) {   export one value with fallback for the file
    return ...;
  }