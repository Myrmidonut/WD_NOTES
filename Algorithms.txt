BIG O NOTATION:
  calculate the performance of an algorithm
  time and space complexity
  ------------------------------
  TIME COMPLEXITY:
    how many calculations

    reductions:
      O(2n)           => O(n)
      O(500)          => O(1)
      O(13n²)         => O(n²)
      O(n + n)        => O(n)
      O(n + 19)       => O(n)
      O(1000n + 50)   => O(n)
      O(n² + 5n + 8)  => O(n²)

    rules:
      arithmetic operation    => constant
      variable assignment     => constant
      array element by index  => constant
      object element by key   => constant
      
      loop                    => length of loop times inside of loop
      
      two loops are better than nested loops

    time:
      faster            slower
      O(1)
        O(log n)
                O(n)
                        O(nlog n)
                          O(n²)
  ------------------------------
  SPACE COMPLEXITY:
    how many items

    auxillary space complexity: only algorithm without inputs

    rules:
      primitives        => constant
        boolean
        number
        undefined
        null
      strings           => O(n), n = length
      array             => O(n), n = length
      object            => O(n), n = number of keys
  ------------------------------
  LOGARITHM:
    log_2(a) = b  => 2^b = a
  ------------------------------
  ARRAYS (JS):
    ordered -> slow

    Access          => O(1)
    Insert
      beginning     => O(n)     .shift
      end           => O(1)     .push
    Remove
      beginning     => O(n)     .unshift
      end           => O(1)     .pop
    Search          => O(n)     for unsorted

    Methods:
      .push         => O(1)
      .pop          => O(1)
      .shift        => O(n)
      .unshift      => O(n)
      .concat       => O(n)
      .slice        => O(n)
      .splice       => O(n)
      .sort         => O(n * log n)
      iterators     => O(n)
        .forEach
        .map
        .filter
        .reduce
  ------------------------------
  OBJECTS (JS):
    unordered -> very fast

    Access              => O(1)
    Insert              => O(1)
    Remove              => O(1)
    Search              => O(n)

    Methods:
      Object.keys()     => O(n)
      Object.values()   => O(n)
      Object.entries()  => O(n)
      .hasOwnProperty   => O(1)
---------------------------------------------------------------------------------------------------
PROBLEMS:
  understand
  explore examples
  break it down
  solve and simplify
  look back and refactor

  UNDERSTAND:
    Restate in own words.

    What are the inputs?
      no input
      too many inputs
      large numbers
      integer, float, string, ...

    What are the outputs?
      integer, float, string, etc.

    Is there enough information to go from input to output?
      0 for not enough inputs

    How to label the important parts?
      many variables
  ------------------------------
  REFACTOR:
    Check the result.
    Derive the result differently.
    Understand it at a glance.
    Use result for other problems.
    Improve performance.
    Other ways of refactoring.
    Solutions by others.
---------------------------------------------------------------------------------------------------
PATTERNS:
  Frequency Counter:
    find elements and their frequency

    examples:
      check if one array consists of squared elements of another array
      check if one string is an anagram of another string

    solution:
      create two objects of unique elements and their frequency and compare them
      Time: 3 loops -> O(n)

  Multiple Pointers;
    requires sorted array

    examples:
      find pairs of elements in an array
      count unique values in an array

    solution:
      2 pointers, in-/decrement both until a pair meets a criteria, move to next pair
      Time: 1 loop -> O(n)
      Space: O(1)

  Sliding Window:
    find subsets
    
    examples:
      unique consecutive elements
      sum of n consecutive elements

    solution:
      create subset and move through array by removing first and adding new element to subset
      Time: 2 loops -> O(n)

  Divide and Conquer:
    create subsets and repeat the process on these subsets
---------------------------------------------------------------------------------------------------
SEARCH:
  Linear Search:
    check every element
    Time: O(n)

  Binary Search:
    sorted data
    cut in half, compare searchelement with last element of first half, repeat
    Time: O(log n)
---------------------------------------------------------------------------------------------------
RECURSION:
  a process that calls itself until it reaches the basecase and ends the recursion
  split into basecase and recursion, both have a return

  Helper Method:
    wrap around initial variable and recursive function

  Pure Recursion:
    

  Javascript:
    function calls are managed by the call stack

  Example:
    function countDown(num) {
      if (num <= 0) {
        console.log("Done!");
        return;
      }
      console.log(num);
      num--;
      countDown(num);
    }

  Example:
    function sumRange(num) {
      if (num === 0) return 1;
      return num + sumRange(num - 1);
    }