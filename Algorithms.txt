BIG O NOTATION:
  calculate the performance of an algorithm
  time and space complexity
  ------------------------------
  TIME COMPLEXITY:
    how many calculations

    reductions:
      O(2n)           => O(n)
      O(500)          => O(1)
      O(13n²)         => O(n²)
      O(n + n)        => O(n)
      O(n + 19)       => O(n)
      O(1000n + 50)   => O(n)
      O(n² + 5n + 8)  => O(n²)

    rules:
      arithmetic operation    => constant
      variable assignment     => constant
      array element by index  => constant
      object element by key   => constant
      
      loop                    => length of loop times inside of loop
      
      two loops are better than nested loops

    fast                                            slow
    O(1)
      O(log n)
            O(n)
                      O(nlog n)
                                        O(n²)
                                                O(2^n)
                                                    O(n!)
  ------------------------------
  SPACE COMPLEXITY:
    how many items

    auxillary space complexity: only algorithm without inputs

    rules:
      primitives        => constant
        boolean
        number
        undefined
        null
      strings           => O(n), n = length
      array             => O(n), n = length
      object            => O(n), n = number of keys
  ------------------------------
  LOGARITHM:
    log_2(a) = b  => 2^b = a
  ------------------------------
  ARRAYS (JS):
    ordered -> slow

    Access          => O(1)
    Insert
      beginning     => O(n)     .shift
      end           => O(1)     .push
    Remove
      beginning     => O(n)     .unshift
      end           => O(1)     .pop
    Search          => O(n)     for unsorted

    Methods:
      .push         => O(1)
      .pop          => O(1)
      .shift        => O(n)
      .unshift      => O(n)
      .concat       => O(n)
      .slice        => O(n)
      .splice       => O(n)
      .sort         => O(n * log n)
      iterators     => O(n)
        .forEach
        .map
        .filter
        .reduce
  ------------------------------
  OBJECTS (JS):
    unordered -> very fast

    Access              => O(1)
    Insert              => O(1)
    Remove              => O(1)
    Search              => O(n)

    Methods:
      Object.keys()     => O(n)
      Object.values()   => O(n)
      Object.entries()  => O(n)
      .hasOwnProperty   => O(1)
---------------------------------------------------------------------------------------------------
PROBLEMS:
  understand
  explore examples
  break it down
  solve and simplify
  look back and refactor

  UNDERSTAND:
    Restate in own words.

    What are the inputs?
      no input
      too many inputs
      large numbers
      integer, float, string, ...

    What are the outputs?
      integer, float, string, etc.

    Is there enough information to go from input to output?
      0 for not enough inputs

    How to label the important parts?
      many variables
  ------------------------------
  REFACTOR:
    Check the result.
    Derive the result differently.
    Understand it at a glance.
    Use result for other problems.
    Improve performance.
    Other ways of refactoring.
    Solutions by others.
---------------------------------------------------------------------------------------------------
PATTERNS:
  Frequency Counter:
    find elements and their frequency

    examples:
      check if one array consists of squared elements of another array
      check if one string is an anagram of another string

    solution:
      create two objects of unique elements and their frequency and compare them
      Time: 3 loops -> O(n)
  ------------------------------
  Multiple Pointers;
    requires sorted array

    examples:
      find pairs of elements in an array
      count unique values in an array

    solution:
      2 pointers, in-/decrement both until a pair meets a criteria, move to next pair
      Time: 1 loop -> O(n)
      Space: O(1)
  ------------------------------
  Sliding Window:
    find subsets
    
    examples:
      unique consecutive elements
      sum of n consecutive elements

    solution:
      create subset and move through array by removing first and adding new element to subset
      Time: 2 loops -> O(n)
  ------------------------------
  Divide and Conquer:
    create subsets and repeat the process on these subsets
---------------------------------------------------------------------------------------------------
RECURSION:
  a process that calls itself until it reaches the basecase and ends the recursion
  split into basecase and recursion, both have a return

  Helper Method:
    wrap around initial variable and recursive function

  Pure Recursion:
    

  Javascript:
    function calls are managed by the call stack
  ------------------------------
  Example:
    function countDown(num) {
      if (num <= 0) {
        console.log("Done!");
        return;
      }
      console.log(num);
      num--;
      countDown(num);
    }

  Example:
    function sumRange(num) {
      if (num === 0) return 1;
      return num + sumRange(num - 1);
    }

    function fib(num) {
      if (num <= 2) return 1;
  
      return fib(num - 1) + fib(num - 2);
    }
---------------------------------------------------------------------------------------------------
SEARCH:
  Linear Search:
    go through whole dataset, check every element

    Best:     O(1)
    Average:  O(n)
    Worst:    O(n)
  ------------------------------
  Binary Search:
    divide and conquer
    sorted
    pointers at beginning, middle and end
    check if value is bigger or smaller than middle
    discard one half and move pointer to middle
    repeat

    Best:     O(1)
    Average:  O(log n)
    Worst:    O(log n)
  ------------------------------
  Naive String Search:
    2 loops
    first loops over bigger string
    second loops over smaller string, starts at first loops position

    O(n²)
  ------------------------------
  KNP:

---------------------------------------------------------------------------------------------------
PRIMITIVE SORT:
  Insertion > Bubble > Selection

  average time complexity of O(n²)

  Insertion/Bubble:
    fast on nearly sorted arrays
    good for streams of data
  ------------------------------
  BUBBLE SORT:
    largest element moves to the end

    compare two elements and swap if wrong order
    check next pair

    Time:
      Best:     O(n)
      Average:  O(n²)
      Worst:    O(n²)

    Space:      O(1)

    Code:
      function bubbleSort(arr) {
        let noSwaps;

        for (let i = arr.length; i > 0; i--) {
          noSwaps = true;

          for (let j = 0; j < i - 1; j++) {
            if (arr[j] > arr[j+1]) {
              let temp = arr[j];
              arr[j] = arr[j + 1];
              arr [j + 1] = temp;
              noSwaps = false;
            }
          }

          if (noSwaps) break;
        }

        return arr;
      }
  ------------------------------
  SELECTION SORT:
    smallest element moves to the front

    set first element to be the smallest
    compare with next elements
    find new smallest element
    move to front afer whole pass
    repeat with next element

    Time:
      Best:     O(n²)
      Average:  O(n²)
      Worst:    O(n²)

    Space:      O(1)

    Code:
      function selectionSort(arr) {
        for (let i = 0; i < arr.length; i++) {
          let lowest = i;

          for (let j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[lowest]) {
                lowest = j;
            }
          }

          if (i !== lowest) {
            let temp = arr[i];
            arr[i] = arr[lowest];
            arr[lowest] = temp;
          }
        }

        return arr;
      }
  ------------------------------
  INSERTION SORT:
    check if next element is bigger than elements in previous subarray
    repeat

    Time:
      Best:     O(n)
      Average:  O(n²)
      Worst:    O(n²)

    Space:      O(1)

    Code:
      function insertionSort(arr) {
        for (let i = 1; i < arr.length; i++) {
          let currentVal = arr[i];

          for (var j = i - 1; j >= 0 && arr[j] > currentVal; j--) {
            arr[j + 1] = arr[j];
          }

          arr[j + 1] = currentVal;
        }

        return arr;
      }
---------------------------------------------------------------------------------------------------
